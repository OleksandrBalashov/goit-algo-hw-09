## Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

### Часова складність

Жадібний алгоритм працює за **O(n)**, де `n` – кількість номіналів монет. Це означає, що він виконує всього кілька операцій, поки залишається сума для розрахунку.

Алгоритм динамічного програмування має складність **O(n \* m)**, де `n` – кількість номіналів монет, а `m` – значення суми. Це робить його значно повільнішим для великих `m` у порівнянні з жадібним методом.

### Продуктивність при великих сумах

- Жадібний алгоритм швидко працює на великих сумах, оскільки він просто вибирає найбільший доступний номінал і повторює процес.
- Динамічне програмування значно повільніше для великих значень `m`, оскільки потрібно обчислювати оптимальне рішення для кожної проміжної суми.

### Оптимальність рішення

- Жадібний алгоритм не завжди знаходить мінімальну кількість монет, особливо якщо набір номіналів не є канонічним (наприклад, якщо є монети 1, 3, 4, то для суми 6 жадібний алгоритм дасть {4,1,1} замість {3,3}).
- Динамічне програмування завжди знаходить оптимальне рішення з мінімальною кількістю монет.

### Висновки

- Жадібний алгоритм є кращим вибором для великих сум, якщо набір монет дозволяє знайти правильне рішення жадібним способом.
- Динамічне програмування гарантує оптимальність, але менш ефективне при великих значеннях суми.
- У реальних застосуваннях доцільно спочатку перевірити, чи є набір монет канонічним, щоб обрати оптимальний метод.
